version: '3'

vars:
  CONFIG_FILE: '{{.CONFIG_FILE | default "config.toml"}}'
  # Fuses
  FUSE_PROD:
    sh: |
      v=$( (dasel -r toml -f '{{.CONFIG_FILE}}' fuses.prod 2>/dev/null || true) | tr -d '"' ); [ -z "$v" ] && v=false; echo "$v"
  # Cluster name (for components that need it)
  CLUSTER_NAME:
    sh: |
      value=$( (dasel -r toml -f '{{.CONFIG_FILE}}' cluster.name 2>/dev/null || true) | tr -d '"' )
      if [ -n "$value" ] && [ "$value" != '""' ]; then echo "$value"; else echo "idp-demo"; fi

  # Network Configuration
  LAN_IP:
    sh: |
      value=$( (dasel -r toml -f '{{.CONFIG_FILE}}' network.lan_ip 2>/dev/null || true) | tr -d '"' )
      if [ -n "$value" ] && [ "$value" != '""' ]; then
        echo "$value"
      else
        ip route get 1.1.1.1 2>/dev/null | awk '{print $7; exit}' || echo "127.0.0.1"
      fi
  NODEPORT_HTTP:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' network.nodeport_http | tr -d '"'
  NODEPORT_HTTPS:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' network.nodeport_https | tr -d '"'

  # Helm Chart Versions
  CILIUM_VERSION:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' versions.cilium | tr -d '"'
  CERT_MANAGER_VERSION:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' versions.cert_manager | tr -d '"'
  GATEWAY_API_VERSION:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' versions.gateway_api | tr -d '"'
  EXTERNAL_SECRETS_VERSION:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' versions.external_secrets | tr -d '"'
  VAULT_VERSION:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' versions.vault | tr -d '"'
  ARGOCD_VERSION:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' versions.argocd | tr -d '"'

  # Operational Settings
  KUBECTL_TIMEOUT:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' operational.kubectl_timeout | tr -d '"'
  GATEWAY_WAIT_TIMEOUT:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' gateway.wait_timeout | tr -d '"'

  # Password Configuration
  ARGOCD_ADMIN_PASSWORD:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' passwords.argocd_admin | tr -d '"'
  GRAFANA_ADMIN_PASSWORD:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' passwords.grafana_admin | tr -d '"'
  SONARQUBE_ADMIN_PASSWORD:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' passwords.sonarqube_admin | tr -d '"'
  SONARQUBE_MONITORING_PASSCODE:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' passwords.sonarqube_monitoring | tr -d '"'

  # Docker Registry Configuration
  DOCKER_REGISTRY_URL:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' registry.url | tr -d '"'
  DOCKER_REGISTRY_USERNAME:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' registry.username | tr -d '"'
  DOCKER_REGISTRY_PASSWORD:
    sh: dasel -r toml -f '{{.CONFIG_FILE}}' registry.password | tr -d '"'

  # Git Configuration
  REPO_URL:
    sh: |
      value=$( (dasel -r toml -f '{{.CONFIG_FILE}}' git.repo_url 2>/dev/null || true) | tr -d '"' )
      if [ -n "$value" ] && [ "$value" != '""' ]; then
        echo "$value"
      else
        git config --get remote.origin.url 2>/dev/null || echo "https://github.com/rou-cru/idp-blueprint.git"
      fi

tasks:
  it:apply-namespaces:
    desc: 'Apply all IT bootstrap namespaces via Kustomize'
    cmds:
      - kustomize build IT/namespaces | kubectl apply -f -

  it:apply-serviceaccounts:
    desc: 'Apply all IT bootstrap ServiceAccounts via Kustomize'
    cmds:
      - kustomize build IT/serviceaccounts | kubectl apply -f -

  it:apply-priorityclasses:
    desc: 'Apply PriorityClasses for pod scheduling'
    cmds:
      - kustomize build IT/priorityclasses | kubectl apply -f -

  it:apply-gateway-api-crds:
    desc: 'Apply Gateway API CRDs'
    cmds:
      - defer: rm -f /tmp/gateway-api-*.yaml
      - |
        GATEWAY_API_VERSION_CLEAN=$(echo {{.GATEWAY_API_VERSION}} | tr -d "'")
        GATEWAY_API_URL="https://github.com/kubernetes-sigs/gateway-api/releases/download/${GATEWAY_API_VERSION_CLEAN}/standard-install.yaml"
        TEMP_FILE="/tmp/gateway-api-${GATEWAY_API_VERSION_CLEAN}.yaml"
        curl -fsSL "$GATEWAY_API_URL" -o "$TEMP_FILE"
        kubectl apply -f "$TEMP_FILE"

  it:apply-prometheus-crds:
    desc: 'Apply Prometheus CRDs from the dedicated Helm chart'
    cmds:
      - |
        helm upgrade --install prometheus-crds prometheus-community/prometheus-operator-crds \
          --version {{.PROMETHEUS_CRDS_VERSION}} \
          --namespace kube-system \
          --hide-notes

  it:apply-crds:
    desc: 'Apply all CRDs required for the platform'
    deps:
      - it:apply-gateway-api-crds
      - it:apply-prometheus-crds

  cilium:preload:
    desc: 'Pre-load Cilium image to Docker host'
    vars:
      CILIUM_IMAGE: 'quay.io/cilium/cilium:v{{.CILIUM_VERSION}}'
    cmds:
      - docker pull {{.CILIUM_IMAGE}}

  cilium:deploy:
    desc: 'Install Cilium as CNI'
    dir: IT/cilium
    preconditions:
      - sh: command -v helm
        msg: 'helm is required but not installed. Run: brew install helm'
      - sh: command -v kubectl
        msg: 'kubectl is required but not installed. Run: brew install kubectl'
    cmds:
      - |
        helm upgrade --install cilium cilium/cilium \
          --version {{.CILIUM_VERSION}} \
          --namespace kube-system \
          --values cilium-values.yaml \
          --set cluster.name={{.CLUSTER_NAME}} \
          --hide-notes
      - kubectl wait --for=condition=Ready pods -l k8s-app=cilium -n kube-system
        --timeout={{.KUBECTL_TIMEOUT}}

  it:bootstrap:
    desc: 'Bootstrap cluster prerequisites and preload images'
    deps:
      - cilium:preload
      - it:apply-serviceaccounts
      - it:apply-crds
      - it:apply-priorityclasses

  cert-manager:deploy:
    desc: 'Deploy Cert-Manager to handle CA'
    dir: IT/cert-manager
    preconditions:
      - sh: command -v helm
        msg: 'helm is required but not installed. Run: brew install helm'
      - sh: command -v kubectl
        msg: 'kubectl is required but not installed. Run: brew install kubectl'
      - sh: command -v kustomize
        msg: 'kustomize is required but not installed. Run: brew install kustomize'
    cmds:
      - |
        helm upgrade --install cert-manager jetstack/cert-manager \
          --version {{.CERT_MANAGER_VERSION}} \
          --namespace cert-manager \
          --values cert-manager-values.yaml \
          --hide-notes
      - kubectl wait --for=condition=Available deployment/cert-manager-webhook -n
        cert-manager --timeout={{.KUBECTL_TIMEOUT}}
      - kustomize build . | kubectl apply -f -

  external-secrets:deploy:
    desc: 'Install External Secrets Operator'
    dir: IT/external-secrets
    preconditions:
      - sh: command -v helm
        msg: 'helm is required but not installed. Run: brew install helm'
      - sh: command -v kubectl
        msg: 'kubectl is required but not installed. Run: brew install kubectl'
    cmds:
      - |
        helm upgrade --install external-secrets external-secrets/external-secrets \
          --version {{.EXTERNAL_SECRETS_VERSION}} \
          --namespace external-secrets-system \
          --values eso-values.yaml \
          --hide-notes
      - kubectl wait --for=condition=available --timeout={{.KUBECTL_TIMEOUT}}
        deployment/external-secrets -n external-secrets-system
      - kubectl wait --for=condition=available --timeout={{.KUBECTL_TIMEOUT}}
        deployment/external-secrets-webhook -n external-secrets-system

  it:eso:apply-resources:
    desc: 'Apply ESO SecretStores and ExternalSecrets'
    dir: IT/external-secrets
    cmds:
      - kustomize build . | kubectl apply -f -
      - kubectl wait --for=condition=Ready externalsecret/argocd-admin-password -n
        argocd --timeout=300s

  vault:clean:
    desc: 'Clean Vault deployment'
    silent: true
    cmds:
      - cmd: helm uninstall vault -n vault-system
        ignore_error: true
      - kubectl delete pvc data-vault-0 -n vault-system --ignore-not-found=true
      - echo "✅ Vault cleaned"

  vault:init:
    desc: 'Initialize Vault and configure for ESO'
    cmds:
      - ./Scripts/vault-init.sh

  vault:generate-secrets:
    desc: 'Generate initial secrets for all services using Vault'
    vars:
      SECRETS:
        - path: 'secret/argocd/admin'
          key: 'admin.password'
          var: 'ARGOCD_ADMIN_PASSWORD'
          enc: 'base64'
          hash: 'bcrypt'
        - path: 'secret/grafana/admin'
          key: 'admin-password'
          var: 'GRAFANA_ADMIN_PASSWORD'
          enc: 'base64'
          hash: 'none'
        - path: 'secret/sonarqube/admin'
          key: 'password'
          var: 'SONARQUBE_ADMIN_PASSWORD'
          enc: 'base64'
          hash: 'none'
        - path: 'secret/sonarqube/monitoring'
          key: 'passcode'
          var: 'SONARQUBE_MONITORING_PASSCODE'
          enc: 'hex'
          hash: 'none'
        - path: 'secret/docker/registry'
          key: 'registry'
          var: 'DOCKER_REGISTRY_URL'
          enc: 'base64'
          hash: 'none'
        - path: 'secret/docker/registry'
          key: 'username'
          var: 'DOCKER_REGISTRY_USERNAME'
          enc: 'base64'
          hash: 'none'
        - path: 'secret/docker/registry'
          key: 'password'
          var: 'DOCKER_REGISTRY_PASSWORD'
          enc: 'base64'
          hash: 'none'
    cmds:
      - for: { var: SECRETS, as: SECRET }
        cmd: ./Scripts/vault-generate.sh {{.SECRET.path}} {{.SECRET.key}} "{{index . .SECRET.var}}" {{.SECRET.enc}} {{.SECRET.hash}}

  vault:deploy:
    desc: 'Deploy HashiCorp Vault'
    dir: IT/vault
    preconditions:
      - sh: command -v helm
        msg: 'helm is required but not installed. Run: brew install helm'
      - sh: command -v kubectl
        msg: 'kubectl is required but not installed. Run: brew install kubectl'
    cmds:
      - |
        helm upgrade --install vault hashicorp/vault \
          --version {{.VAULT_VERSION}} \
          --namespace vault-system \
          --values vault-values.yaml \
          --hide-notes
      - task: vault:init
      - task: vault:generate-secrets

  it:deploy-secret-and-certs:
    desc: 'Deploy cert-manager and vault'
    deps:
      - cert-manager:deploy
      - vault:deploy

  argocd:deploy:
    desc: 'Deploy ArgoCD GitOps Engine'
    dir: IT/argocd
    preconditions:
      - sh: command -v helm
        msg: 'helm is required but not installed. Run: brew install helm'
      - sh: command -v kubectl
        msg: 'kubectl is required but not installed. Run: brew install kubectl'
      - sh: command -v envsubst
        msg: 'envsubst is required but not installed. Run: brew install gettext'
    env:
      REPO_URL: '{{.REPO_URL}}'
    cmds:
      - |
        EXTRA_ARGS=""
        if [ "{{.FUSE_PROD}}" = "true" ]; then
          EXTRA_ARGS="--set ha.enabled=true"
        fi
        helm upgrade --install argocd argo/argo-cd \
          --version {{.ARGOCD_VERSION}} \
          --namespace argocd \
          --values argocd-values.yaml \
          $EXTRA_ARGS \
          --hide-notes
      - kubectl wait --for=condition=Available deployment/argocd-server -n argocd
        --timeout={{.KUBECTL_TIMEOUT}}
      - task: it:eso:apply-resources
      - for: [platform, observability, cicd, security]
        cmd: envsubst < appproject-{{.ITEM}}.yaml | kubectl apply -f -

  gateway:deploy:
    desc: 'Deploy Gateway API Gateway resource'
    dir: IT/gateway
    preconditions:
      - sh: command -v kustomize
        msg: 'kustomize is required but not installed. Run: brew install kustomize'
      - sh: command -v kubectl
        msg: 'kubectl is required but not installed. Run: brew install kubectl'
      - sh: command -v envsubst
        msg: 'envsubst is required but not installed. Run: brew install gettext'
    env:
      DNS_SUFFIX:
        sh: |
          value=$( (dasel -r toml -f '{{.CONFIG_FILE}}' network.lan_ip 2>/dev/null || true) | tr -d '"' | tr -d "'" )
          if [ -z "$value" ] || [ "$value" = "''" ]; then
            value=$(ip route get 1.1.1.1 2>/dev/null | awk '{print $7; exit}' || echo "127.0.0.1")
          fi
          echo "$(echo "$value" | tr '.' '-').nip.io"
    cmds:
      - kustomize build . | envsubst | kubectl apply -f -
      - sleep 5
      - kubectl apply -f patch/gateway-service-patch.yaml
      - |
        HTTP_PORT=$(kubectl get svc cilium-gateway-idp-gateway -n kube-system -o jsonpath='{.spec.ports[?(@.name=="port-80")].nodePort}')
        HTTPS_PORT=$(kubectl get svc cilium-gateway-idp-gateway -n kube-system -o jsonpath='{.spec.ports[?(@.name=="port-443")].nodePort}')
        if [ "$HTTP_PORT" != "{{.NODEPORT_HTTP}}" ] || [ "$HTTPS_PORT" != "{{.NODEPORT_HTTPS}}" ]; then
          echo "❌ NodePort patch failed! HTTP=$HTTP_PORT (expected {{.NODEPORT_HTTP}}), HTTPS=$HTTPS_PORT (expected {{.NODEPORT_HTTPS}})"
          exit 1
        fi
        echo "✅ NodePorts verified: HTTP={{.NODEPORT_HTTP}}, HTTPS={{.NODEPORT_HTTPS}}"
      - kubectl wait --for=condition=Programmed gateway/idp-gateway -n kube-system
        --timeout={{.KUBECTL_TIMEOUT}}
      - |
        echo "✅ Gateway ready. Services available at:"
        echo "   https://argocd.$DNS_SUFFIX"
        echo "   https://grafana.$DNS_SUFFIX"
        echo "   https://vault.$DNS_SUFFIX"
        echo "   https://sonarqube.$DNS_SUFFIX"
        echo "   https://workflows.$DNS_SUFFIX"
