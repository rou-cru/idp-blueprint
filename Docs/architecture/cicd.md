# CI/CD stack — Argo Workflows + SonarQube

The `K8s/cicd/` directory hosts everything developers need to run workflows, quality scans, and build-time policies inside the IDP.

From a C4 perspective this page is a **component view (L3)** of the CI/CD part of the developer‑facing stacks.

## Components

| Component | Path | Highlights |
| --- | --- | --- |
| Argo Workflows | `K8s/cicd/argo-workflows/` | Workflow controller + server with metrics + RBAC locked to `cicd` namespace. |
| Governance manifests | `K8s/cicd/governance/` | ResourceQuota + LimitRange to keep demo workloads lightweight. |
| SonarQube | `K8s/cicd/sonarqube/` | Community edition with Vault-managed admin password + monitoring passcode. |

### Repo wiring & tasks

- ApplicationSet: `K8s/cicd/applicationset-cicd.yaml` watches `K8s/cicd/*` and generates Applications per subfolder.
- Deploy only CI/CD stack: `task stacks:cicd` (after bootstrap).
- Secrets are seeded from Vault using External Secrets; defaults can come from `config.toml` (passwords.sonarqube_*), or are generated by `vault:generate-secrets`.

## Workflow Execution Flow

```d2
direction: right

Dev: {
  label: "Developer"
  shape: c4-person
}

Git: {
  label: "Git repo\nWorkflow YAML"
}

ArgoUI: {
  label: "Argo Workflows\nUI / CLI"
}

Controller: {
  label: "Workflow controller"
}

Pods: {
  label: "Workflow pods"
}

Sonar: {
  label: "SonarQube"
}

Dev -> Git: "commit workflow template"
Dev -> ArgoUI: "submit workflow"
Git -> ArgoUI: "reference Git artifact"
ArgoUI -> Controller: "create Workflow CR"
Controller -> Pods: "launch pods\n(priority: cicd-execution)"
Pods -> Sonar: "run quality gate"
Controller -> Dev: "status in UI / CLI / metrics"
```

## Secrets & Credentials

- **Argo Workflows** authenticates to Vault-backed secrets via External Secrets (see `argo-workflows-values.yaml` and `IT/external-secrets/`).
- **SonarQube admin & monitoring tokens** come from Vault and are injected by Helm after ESO syncs the secret.
- Additional CI secrets follow the same pattern: define them in Vault, sync via `ExternalSecret`, mount as env vars in workflow pods.

## Observability Hooks

- Workflow controller metrics are scraped by Prometheus via `ServiceMonitor` and surfaced in Grafana.
- Argo emits Kubernetes events; Fluent-bit ships them to Loki so you can tail workflow logs centrally.
- SonarQube exposes readiness/liveness probes along with JVM metrics—enable dashboards for quality gates and scan times.

### Verify

- Workflows UI: `https://workflows.<ip-dashed>.nip.io` via Gateway
- SonarQube UI: `https://sonarqube.<ip-dashed>.nip.io`
- Controller healthy: `kubectl -n cicd get deploy argo-workflows-controller`

## Extending the Stack

1. **Add Workflows** – store reusable templates under `K8s/cicd/argo-workflows/templates/` (or similar), include them via ConfigMaps, and reference them in Workflow manifests.
2. **Add Build Tools** – create subdirectories (e.g., `kaniko/`, `tekton/`) and update `applicationset-cicd.yaml` so ArgoCD auto-syncs them.
3. **Expose CI Services** – enable Ingress/Gateway entries in values files to expose SonarQube or Argo Workflows UI via the platform Gateway.
4. **Integrate pipelines** – Use Argo Events or GitHub webhooks (future work) to trigger workflows automatically.

## Example: Quality Gate Workflow

```d2
direction: right

Code: "Source Repo"
Build: "Build & Test"
Scan: "SonarQube Scan"
Gate: {
  label: "Quality Gate"
}
Deploy: "GitOps Merge"

Code -> Build -> Scan -> Gate
Gate -> Deploy: pass
Gate -> Code: fail
```

In Argo Workflows, this translates to a DAG with `build` → `sonarqube-scan` → `quality-gate`. The scan step reaches out to SonarQube using the Vault-provisioned monitoring token.
