# CI/CD Stack (Argo Workflows + SonarQube)

The `K8s/cicd/` directory hosts everything developers need to run workflows, quality scans, and build-time policies inside the IDP.

## Components

| Component | Path | Highlights |
| --- | --- | --- |
| Argo Workflows | `K8s/cicd/argo-workflows/` | Workflow controller + server with metrics + RBAC locked to `cicd` namespace. |
| Governance manifests | `K8s/cicd/governance/` | ResourceQuota + LimitRange to keep demo workloads lightweight. |
| SonarQube | `K8s/cicd/sonarqube/` | Community edition with Vault-managed admin password + monitoring passcode. |

### Repo wiring & tasks

- ApplicationSet: `K8s/cicd/applicationset-cicd.yaml` watches `K8s/cicd/*` and generates Applications per subfolder.
- Deploy only CI/CD stack: `task stacks:cicd` (after bootstrap).
- Secrets are seeded from Vault using External Secrets; defaults can come from `config.toml` (passwords.sonarqube_*), or are generated by `vault:generate-secrets`.

## Workflow Execution Flow

```d2
shape: sequence_diagram
Dev: Developer
Git: Repo (Workflow YAML)
ArgoUI: Argo CLI / UI
Controller: Workflow Controller
Pods: Workflow Pods
Sonar: SonarQube

Dev -> Git: Commit workflow template
Dev -> ArgoUI: Submit workflow (Git artifact)
ArgoUI -> Controller: Create Workflow CR
Controller -> Pods: Launch pods (priority: cicd-execution)
Pods -> Sonar: Quality gate (token/webhook)
Pods -> Controller: Results + artifacts
Controller -> Dev: Status in UI/CLI/metrics
```

## Secrets & Credentials

- **Argo Workflows** authenticates to Vault-backed secrets via External Secrets (see `argo-workflows-values.yaml` and `IT/external-secrets/`).
- **SonarQube admin & monitoring tokens** come from Vault and are injected by Helm after ESO syncs the secret.
- Additional CI secrets follow the same pattern: define them in Vault, sync via `ExternalSecret`, mount as env vars in workflow pods.

## Observability Hooks

- Workflow controller metrics are scraped by Prometheus via `ServiceMonitor` and surfaced in Grafana.
- Argo emits Kubernetes events; Fluent-bit ships them to Loki so you can tail workflow logs centrally.
- SonarQube exposes readiness/liveness probes along with JVM metrics—enable dashboards for quality gates and scan times.

### Verify

- Workflows UI: `https://workflows.<ip-dashed>.nip.io` via Gateway
- SonarQube UI: `https://sonarqube.<ip-dashed>.nip.io`
- Controller healthy: `kubectl -n cicd get deploy argo-workflows-controller`

## Extending the Stack

1. **Add Workflows** – store reusable templates under `K8s/cicd/argo-workflows/templates/` (or similar), include them via ConfigMaps, and reference them in Workflow manifests.
2. **Add Build Tools** – create subdirectories (e.g., `kaniko/`, `tekton/`) and update `applicationset-cicd.yaml` so ArgoCD auto-syncs them.
3. **Expose CI Services** – enable Ingress/Gateway entries in values files to expose SonarQube or Argo Workflows UI via the platform Gateway.
4. **Integrate pipelines** – Use Argo Events or GitHub webhooks (future work) to trigger workflows automatically.

## Example: Quality Gate Workflow

```d2
direction: right

Code: "Source Repo"
Build: "Build & Test"
Scan: "SonarQube Scan"
Gate: {
  label: "Quality Gate"
}
Deploy: "GitOps Merge"

Code -> Build -> Scan -> Gate
Gate -> Deploy: pass
Gate -> Code: fail
```

In Argo Workflows, this translates to a DAG with `build` → `sonarqube-scan` → `quality-gate`. The scan step reaches out to SonarQube using the Vault-provisioned monitoring token.
