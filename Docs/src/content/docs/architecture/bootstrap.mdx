---
title: Bootstrap Layer
description: Bootstrap Layer
layout: ../../../layouts/DocsLayout.astro
sidebar:
  label: Bootstrap
  order: 2
---
import { Button } from '../../../components/content/index.ts';

The **Bootstrap Layer** is the engine responsible for turning a collection of static definitions into a living platform. It solves the "chicken-and-egg" problem of Kubernetes: you need a cluster to run ArgoCD, but you need ArgoCD to manage the cluster.

In this architecture, **Task** (`Taskfile.yaml`) acts as the imperative orchestrator that bridges this gap, handling the critical minutes between "empty laptop" and "GitOps ready".

## The Orchestrator: Taskfile

We chose `task` over simple shell scripts or Makefiles to provide a robust, self-documenting interface for the platform's lifecycle. It encapsulates complexity, managing everything from local environment variables to the precise order of Helm chart applications.

The bootstrap process isn't just running `kubectl apply`. It requires careful coordination of dependencies that cannot be purely declarative, such as:
1.  **Secret Generation**: Creating strong crypto credentials for Vault and initial users.
2.  **Wait Conditions**: Pausing until CRDs are established or webhooks are active.
3.  **Environment Injection**: Templating configuration files with local IP addresses for ingress.

### Bootstrap timeline

![Bootstrap Timeline](../assets/diagrams/architecture/bootstrap-timeline.svg)

## Custom Automation Highlights

While standard tools like Helm do the heavy lifting, we developed specific automation to handle the unique constraints of a local, air-gapped-capable IDP.

### 1. Zero-Touch Vault Initialization
Traditionally, HashiCorp Vault requires manual operator intervention to "unseal" it after deployment. We automated this using `Scripts/vault-init.sh`.
*   **What it does:** It initializes the Vault implementation, securely captures the unseal keys and root token, and then immediately unseals the vault so other components (like External Secrets) can connect.
*   **Why it matters:** It allows the entire platform to deploy unattended. You can run `task deploy` and walk away.

### 2. Dynamic Ingress Wiring (`nip.io`)
A major challenge in local Kubernetes is getting valid TLS certificates and real DNS names without owning a domain or using a cloud LoadBalancer.
*   **The Solution:** The orchestrator detects your machine's local LAN IP and injects it into the Gateway API configuration using `nip.io` (a wildcard DNS service).
*   **The Result:** You get real URLs like `https://argocd.192-168-1-50.nip.io` that work from any device on your network, with zero manual DNS configuration.

### 3. Gateway API Patching
The Gateway API is the modern standard for ingress, but wiring it to a local `nodePort` service on a specific port (so you don't need `sudo` to bind port 443) requires precise patching.
*   **Automation:** The bootstrap task waits for the Gateway to be programmed and then verifies that the NodePorts match the configuration in `config.toml`, ensuring predictable access points.

## Sequence of Events

The orchestrator executes the following sequence to reach a GitOps-ready state:

1.  **Cluster & Foundation:** Provisions the k3d nodes and applies essential CRDs (Prometheus, Gateway API).
2.  **Networking & Security:** Installs Cilium and Cert-Manager, establishing the secure transport layer.
3.  **Identity & Secrets:** Deploys Vault, runs the auto-unseal automation, and configures the External Secrets Operator to trust it.
4.  **GitOps Handover:** Finally, deploys ArgoCD. Once ArgoCD is healthy, the `Taskfile`'s job is largely doneâ€”ArgoCD takes over and hydrates the rest of the platform from Git.

<div class="flex justify-center gap-3 mt-8">
  <Button href="/architecture/overview/" variant="secondary" icon="arrow-left">
    Back: Overview
  </Button>
  <Button href="/architecture/infrastructure/" variant="primary" icon="arrow-right">
    Next: Infrastructure
  </Button>
</div>
