---
title: Secrets Management
description: Secrets Management
layout: ../../../layouts/DocsLayout.astro
sidebar:
  label: Secrets Management
  order: 5
---
import { Button } from '../../../components/content/index.ts';

## The Architecture of Trust

A robust secrets management architecture is fundamental to any secure platform. Our approach establishes a "Production-Grade" secrets pipeline that is centralized, automated, and platform-agnostic, ensuring sensitive data is handled with integrity across diverse environments.

Instead of scattering API keys and passwords across various sources like CI variables, local files, or directly in Kubernetes Secrets, we enforce a strictly unidirectional flow of trust. This design prioritizes a single, authoritative source for all credentials and cryptographic keys.

![Secrets Management Architecture](../assets/diagrams/architecture/secrets-architecture.svg)

At the heart of this system is a **centralized secrets store**, acting as the encrypted, audited backend for all sensitive data—from database passwords to API tokens. While this blueprint leverages HashiCorp Vault for this role, the underlying architecture is pluggable, allowing for integration with any equivalent secrets manager, be it cloud-managed or self-hosted.

Bridging the gap between the secrets store's API and application consumption is an **intelligent operator**. This component runs within the platform, securely authenticating to the central store and watching for declarative requests for secrets. When an application defines its need for a secret, this operator fetches it and injects it into the consumption environment (e.g., as a standard Kubernetes Secret). This abstraction ensures that applications never need direct knowledge of the secrets store, consuming credentials via familiar interfaces like environment variables or volume mounts.

This entire lifecycle operates within a **GitOps framework**. Recognizing that secret values themselves cannot be committed to version control, we manage their lifecycle through declarative definitions. These definitions specify *what* secret to fetch (e.g., its path and key), but contain no actual sensitive data. ArgoCD synchronizes these definitions, and the secrets operator then hydrates them with the real values at runtime.

## Synchronization Patterns

The architecture supports two distinct synchronization patterns depending on where a workload consumes its sensitive data: In-Cluster Sync (Pull) for platform components, and Cross-Cloud Sync (Push) for external infrastructure.

### In-Cluster Sync

For workloads running directly within the Kubernetes platform, such as microservices or platform components, we rely on a **Pull** model. A developer declares the required secret using a custom resource. The secrets operator detects this request, authenticates against the central secrets store, and retrieves the specified value. It then dynamically generates a native Kubernetes Secret in the application's namespace. This creates a highly secure boundary, ensuring the secret material only materializes in the precise location and scope where it is genuinely needed by the consuming application.

### Cross-Cloud Sync

For external workloads, such as serverless functions (e.g., AWS Lambda) or managed database instances, we utilize a **Push** model. Here, the secrets operator retrieves the necessary value from the central store and actively pushes it to an external provider's native secret manager (e.g., AWS Secrets Manager). This pattern allows the Kubernetes platform to act as a control plane for cloud-specific secrets, maintaining the central store as the master record while satisfying the native requirements of diverse cloud services.

## Security Posture

In this blueprint, security-by-design is paramount. Our approach fosters a zero-trust environment for version control, ensuring that absolutely no actual secret values ever touch Git. Even initial bootstrap credentials are dynamically generated or securely injected at runtime. Automation underpins our rotation policy; since the secrets operator continuously reconciles with the central store, updating a credential there automatically propagates the change to all consuming applications or external systems without manual intervention. Furthermore, we enforce least privilege by authenticating the operator to the central store using finely scoped Kubernetes Service Accounts, ensuring only the necessary components—not every individual developer—require direct access to the secrets store's API.

<div class="flex justify-center gap-3 mt-8">
  <Button href="/architecture/applications/" variant="secondary" icon="arrow-left">
    Back: Applications
  </Button>
  <Button href="/architecture/policies/" variant="primary" icon="arrow-right">
    Next: Policies
  </Button>
</div>