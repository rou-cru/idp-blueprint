---
title: Application Architecture
description: Application Architecture
layout: ../../../layouts/DocsLayout.astro
sidebar:
  label: Applications
  order: 4
---
import { Button } from '../../../components/content/index.ts';

While the infrastructure core provides the necessary substrate—compute, networking, and secrets—it is the **Application Layer** that delivers actual value to developers. This layer is not a monolithic block but a composition of distinct, domain-focused **Stacks** managed entirely through GitOps.

We organize these stacks to provide a cohesive platform experience, where tools are not just installed side-by-side but are integrated to support complete engineering workflows.

## The Observability Stack

Visibility is the first requirement of any reliable platform. We implemented a comprehensive observability strategy that goes beyond simple dashboards, enabling a culture of Service Level Objectives (SLOs).

The backbone of this stack is the **Kube Prometheus Stack**, which deploys Prometheus for metric collection and Grafana for visualization. It comes pre-loaded with rich dashboards that monitor the platform's own health—from Cilium networking flows to ArgoCD performance.

To complement metrics with context, we deploy **Loki** as a lightweight log aggregation system, fed by **Fluent-bit** collectors running on every node. This ensures that developers can correlate a spike in error rates directly with the application logs that explain them, all within a single Grafana interface.

Taking reliability engineering a step further, we include **Pyrra**. This tool transforms SLOs from abstract concepts into first-class Kubernetes resources. Engineers can define availability targets in YAML (e.g., "99.9% success rate for the API"), and Pyrra automatically generates the necessary Prometheus recording rules and alerting configurations.

## The CI/CD Stack

Delivering code to production requires a robust factory floor. The CI/CD stack provides the engines necessary to build, test, and verify software supply chains.

**Argo Workflows** serves as the general-purpose workflow engine. Unlike traditional CI systems that rely on heavy agents, Argo Workflows runs every step of the pipeline as a container in the cluster, allowing for massive parallelism and native integration with Kubernetes resources.

Quality gates are enforced by **SonarQube**, which performs static analysis on codebases to detect bugs, vulnerabilities, and code smells before they merge. By integrating this into the pipeline, we shift quality left, preventing technical debt from accumulating in the platform.

## The Eventing Stack

A truly modern IDP is reactive, not just passive. The Eventing stack creates a nervous system for the platform, allowing it to respond automatically to changes in state.

We utilize **Argo Events** to capture signals from various sources—such as webhooks from GitHub, resource changes in Kubernetes, or alerts from Prometheus. These events trigger sensors that can execute complex remediation logic or launch provisioning workflows. For example, a "High Error Rate" alert could automatically trigger a remediation workflow to capture a heap dump or rollback a deployment, closing the loop between observability and action.

## The Security Stack

Security in the IDP is continuous and embedded, not a final checkpoint. The Security stack ensures that workloads maintain a strong posture throughout their lifecycle.

**Trivy Operator** sits inside the cluster, continuously scanning running container images for known vulnerabilities (CVEs). This provides real-time visibility into the security risks of the fleet, alerting platform engineers to new threats in already-deployed software without waiting for the next build cycle.

## The Developer Portal (Backstage)

Finally, **Backstage** acts as the unified frontend for the entire platform. It aggregates information from all the underlying stacks—services from the catalog, build status from CI/CD, and documentation—into a single pane of glass.

To secure this portal, we integrate **Dex** as an OpenID Connect provider. This handles identity federation, allowing developers to log in using standard Git providers or enterprise identity systems, ensuring that the portal remains secure while offering a seamless user experience.

<div class="flex justify-center gap-3 mt-8">
  <Button href="/architecture/infrastructure/" variant="secondary" icon="arrow-left">
    Back: Infrastructure
  </Button>
  <Button href="/architecture/secrets/" variant="primary" icon="arrow-right">
    Next: Secrets Management
  </Button>
</div>
