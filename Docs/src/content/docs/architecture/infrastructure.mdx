---
title: Infrastructure Core
description: Infrastructure Core
layout: ../../../layouts/DocsLayout.astro
sidebar:
  label: Infrastructure
  order: 3
---
import { Button } from '../../../components/content/index.ts';

The **Infrastructure Core** represents the "physical" and logical foundation of the IDP. Before we can talk about Developer Portals or CI/CD pipelines, we need a reliable substrate that handles compute, networking, identity, and secrets.

This layer is designed to be **cloud-agnostic** but optimized for resource-constrained environments (like a laptop or edge server). It replaces managed cloud services (AWS ALB, KMS, EKS) with open-source, self-hosted equivalents.

## Compute: k3d & k3s

We use **k3s** (via k3d) as the Kubernetes distribution.
*   **Why:** It is a fully CNCF-compliant Kubernetes distribution but stripped of legacy cloud provider binaries, making it incredibly lightweight.
*   **Topology:** The blueprint provisions a **3-node cluster** (1 Server + 2 Agents). This mimics a real production environment where workloads are separated from the control plane using scheduling rules (taints and tolerations), allowing you to test resilience scenarios like node failure locally.

## Networking: Cilium & Gateway API

Instead of the standard `kube-proxy` and generic Ingress controllers (like Nginx), this architecture adopts the modern networking stack.

*   **Cilium (CNI):** Uses eBPF to handle networking at the kernel level. It provides superior performance and, crucially for a platform, deep observability and security capabilities that standard IPTables-based networking cannot match.
*   **Gateway API:** The successor to the Ingress API. It allows us to define networking intent in a more expressive way, separating the role of the Cluster Operator (who manages the Gateway) from the Developer (who attaches Routes).

## Identity & Secrets: Vault & ESO

Handling sensitive data is often the hardest part of a local platform. We solve this by implementing a full "Production-Grade" secrets pipeline.

*   **HashiCorp Vault:** Acts as the centralized source of truth for secrets. In a real enterprise, this would be your corporate Vault or AWS Secrets Manager. Here, we self-host it to prove the pattern.
*   **External Secrets Operator (ESO):** Bridging the gap between Vault and Kubernetes. Applications shouldn't talk to Vault directly (it's complex). ESO automatically fetches secrets from Vault and injects them as native Kubernetes Secrets, so apps just see standard environment variables.

## GitOps Engine: ArgoCD

The heart of the platform's automation. Once the infrastructure core is bootstrapped, **ArgoCD** takes over. It is the only component that has permission to write to the cluster (eventually). By placing ArgoCD in the core infrastructure, we ensure that even the platform's own configuration is managed via GitOps.

## Component View

The diagram below illustrates the static relationships between these components. Unlike the runtime view, this focuses on dependencies: how the Secrets system relies on Vault, how Ingress relies on the Gateway, and how they all act as dependencies for the Application Layer that follows.

![Infrastructure Component View](../assets/diagrams/architecture/infrastructure-component-view.svg)

<div class="flex justify-center gap-3 mt-8">
  <Button href="/architecture/bootstrap/" variant="secondary" icon="arrow-left">
    Back: Bootstrap
  </Button>
  <Button href="/architecture/applications/" variant="primary" icon="arrow-right">
    Next: Applications
  </Button>
</div>
