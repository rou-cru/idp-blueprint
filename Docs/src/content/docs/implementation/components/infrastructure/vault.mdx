---
title: vault
sidebar:
  label: Vault
  order: 5
---

import MarkdownPartial from '../../../../../components/MarkdownPartial.astro';
import vaultValuesRaw from '../../../../../partials/helm-docs/vault_values.generated.md?raw';

![Version: latest](https://img.shields.io/badge/Version-latest-informational?style=flat-square)
![Type: application](https://img.shields.io/badge/Type-application-informational?style=flat-square)
[![Homepage](https://img.shields.io/badge/Homepage-blue)](https://www.vaultproject.io)

Secrets management and data protection platform

## Component Information

| Property | Value |
|----------|-------|
| **Chart Version** | `latest` |
| **Chart Type** | `application` |
| **Upstream Project** | [vault](https://www.vaultproject.io) |
| **Maintainers** | Platform Engineering Team ([repo](https://github.com/rou-cru/idp-blueprint)) |

## Why Vault?

Using cloud provider secret managers creates vendor lock-in and forces the platform to handle
provider-specific APIs. Vault provides a provider-agnostic secrets backend that runs anywhere
Kubernetes runs.

Benefits of this approach:

- **No Vendor Lock-In**: Vault works the same on AWS, GCP, Azure, or bare metal
- **Centralized Management**: Single source of truth for all secrets across the platform
- **Automated Rotation**: Supports dynamic secrets and automatic rotation
- **Audit Trail**: Every secret access is logged
- **Developer-Friendly**: Applications consume standard Kubernetes Secrets, not Vault's API
  directly

## Architecture Role

Vault sits at **Layer 1** of the platform, the Platform Services layer. It's a cross-cutting
service that nearly every component depends on for credentials.

Key integration points:

- **External Secrets Operator**: Syncs secrets from Vault into Kubernetes Secrets
- **ArgoCD**: Consumes Vault secrets for repository credentials
- **Grafana**: Uses Vault-sourced secrets for admin passwords and datasource credentials
- **Applications**: Consume secrets via standard Kubernetes Secrets, decoupled from Vault's API

The configuration here uses `dev` mode for the demo (data stored in memory, auto-unsealed).
In production, Vault would run in `ha` mode with persistent storage and external unseal keys.
The architecture supports both without changes to dependent components.

See [Secrets Management](../../architecture/secrets) for the complete secrets flow.

## Configuration Values

<MarkdownPartial content={vaultValuesRaw} />
